import { Diagnostic, DiagnosticSeverity, IConnection, TextDocument } from 'vscode-languageserver';
import { ANTLRErrorListener, ANTLRInputStream, CommonTokenStream, 
         RecognitionException, Recognizer, Token } from 'antlr4ts';
import { VisualBasic6Lexer } from "./VisualBasic6/VisualBasic6Lexer";
import { VisualBasic6Parser } from "./VisualBasic6/VisualBasic6Parser";

class DescriptiveErrorListener implements ANTLRErrorListener<Token> {
    private diagnostics : Diagnostic[];
    constructor(diagnostics:Diagnostic[]) {
        this.diagnostics = diagnostics;
    };
    /**
   * Upon syntax error, notify any interested parties. This is not how to
   * recover from errors or compute error messages. {@link ANTLRErrorStrategy}
   * specifies how to recover from syntax errors and how to compute error
   * messages. This listener's job is simply to emit a computed message,
   * though it has enough information to create its own message in many cases.
   *
   * <p>The {@link RecognitionException} is non-null for all syntax errors except
   * when we discover mismatched token errors that we can recover from
   * in-line, without returning from the surrounding rule (via the single
   * token insertion and deletion mechanism).</p>
   *
   * @param recognizer
   *        What parser got the error. From this
   * 		  object, you can access the context as well
   * 		  as the input stream.
   * @param offendingSymbol
   *        The offending token in the input token
   * 		  stream, unless recognizer is a lexer (then it's null). If
   * 		  no viable alternative error, {@code e} has token at which we
   * 		  started production for the decision.
   * @param line
   * 		  The line number in the input where the error occurred.
   * @param charPositionInLine
   * 		  The character position within that line where the error occurred.
   * @param msg
   * 		  The message to emit.
   * @param e
   *        The exception generated by the parser that led to
   *        the reporting of an error. It is null in the case where
   *        the parser was able to recover in line without exiting the
   *        surrounding rule.
   */
    syntaxError?: <T extends Token>(
        recognizer: Recognizer<T, any>, 
        offendingSymbol: T | undefined, 
        line: number, 
        charPositionInLine: number, 
        msg: string, 
        e: RecognitionException | undefined) => void = 
        (recognizer, offendingSymbol, line, charPositionInLine, msg, e) => {
            console.log(recognizer, e);

            this.diagnostics.push({
                severity: DiagnosticSeverity.Error,
                range: {
                    start: { line: line - 1, character: charPositionInLine },
                    end: { line: line - 1, character: charPositionInLine }
                },
                message: `Line (${line}, ${charPositionInLine}): ${msg} [${offendingSymbol.text}]`,
                source: 'ex'
            });
        }
}

export let validateTextDocument = (doc: TextDocument, connection: IConnection): void => {
    let diagnostics: Diagnostic[] = [];
    // Create the lexer and parser
    let inputStream = new ANTLRInputStream(doc.getText());
    let lexer = new VisualBasic6Lexer(inputStream);
    let tokenStream = new CommonTokenStream(lexer);
    let parser = new VisualBasic6Parser(tokenStream);

    let listener:DescriptiveErrorListener = new DescriptiveErrorListener(diagnostics);
    parser.removeErrorListeners();
    parser.addErrorListener(listener);

    parser.buildParseTree = true;
    parser.startRule();

    //console.log(tree);
    // Parse the input, where `compilationUnit` is whatever entry point you defined
    //let result = parser.compilationUnit();

    /*
    let lines: string[] = doc.getText().split(/\r?\n/g);
    for (let i = 0; i < lines.length; i++) {
        let line: string = lines[i];
        let words: string[] = line.split(" ");

        words.forEach((word, index) => {
            let keyIndex = findKey(word);
            if (keyIndex >= 0) {
                diagnostics.push({
                    severity: DiagnosticSeverity.Warning,
                    range: {
                        start: { line: i, character: line.indexOf(word) },
                        end: { line: i, character: line.indexOf(word) + word.length }
                    },
                    message: `${word} should be spelled TypeScript 2`,
                    source: 'ex'
                });
            }
        });
    }*/
    // Send the computed diagnostics to VSCode.
    connection.sendDiagnostics({ uri: doc.uri, diagnostics });
}

/*let findKey = (word: string): number => {
    let result: number = -1;
    keywords.forEach((keyword, index) => {
        if (keyword.key.toLowerCase() === word.toLowerCase()) {
            result = index;
        }
    });

    return result;
}*/